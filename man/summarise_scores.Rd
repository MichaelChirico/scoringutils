% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/summarise_scores.R
\name{summarise_scores}
\alias{summarise_scores}
\title{Summarise scores as produced by \code{\link[=score]{score()}}}
\usage{
summarise_scores(scores, by, FUN = mean, ...)
}
\arguments{
\item{scores}{a data.table of unsummarised scores as produced by
\code{\link[=score]{score()}}}

\item{by}{character vector with column names to summarise scores by.}

\item{FUN}{a function used for summarising scores. Default is \code{mean}.}

\item{...}{additional parameters passed down to lower-level functions.
For example, the following arguments can change how weighted interval
scores are computed:
\itemize{
\item \code{count_median_twice} that controls how the interval scores for different
intervals are summed up. This should be a logical (default is \code{FALSE}) that
indicates whether or not to count the median twice when summarising.
This would conceptually treat the
median as a 0\% prediction interval, where the median is the lower as well as
the upper bound. The alternative is to treat the median as a single quantile
forecast instead of an interval. The interval score would then
be better understood as an average of quantile scores.)
}}
}
\description{
Summarise scores as produced by \code{\link[=score]{score()}}-
}
\examples{
library(scoringutils)
data <- example_quantile
scores <- score(data,
                summarise_by = c("model", "target_type", "location",
                                 "horizon", "range", "quantile"))

# get scores by model
summarise_scores(scores, by = c("model"))

# get scores by model and target type
summarise_scores(scores, by = c("model", "target_type"))

# get standard deviation
summarise_scores(scores, by = "model", FUN = sd)

# get quantiles of scores
# make sure to aggregate over ranges first
summarise_scores(scores, by = "model", FUN = quantile,
                 probs = c(0.25, 0.5, 0.75))

# get ranges
# summarise_scores(scores, by = "range")

}
