% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eval_forecasts.R
\name{eval_forecasts}
\alias{eval_forecasts}
\title{Evaluate forecasts}
\usage{
eval_forecasts(
  data,
  by,
  summarise_by = by,
  quantiles = c(),
  sd = FALSE,
  pit_plots = FALSE,
  pit_arguments = list(plot = FALSE),
  interval_score_arguments = list(weigh = TRUE)
)
}
\arguments{
\item{data}{A data.frame or data.table with the correct columns.
Note: it is easiest to have a look at the example files provided in the
package and in the examples below.
Regardless of the forecast type,the following columns need to be present:
\itemize{
  \item \code{true_values} the true observed values
  \item \code{id} A unique identifier of the true values. Could be a date
  or just a running index}
All forecasts except the quantile forecasts need a \code{predictions} column:
\itemize{
\item \code{predictions} predictions or predictive samples for one
  true value.}
For integer and continuous forecasts a \code{sample} column is needed:
\itemize{
  \item \code{sample} an index to identify the predictive samples in the
  predictiions column generated by one model for one true value. Only
  necessary for continuous and integer forecasts, not for
  binary predictions.}
For quantile forecasts the data can either be provided in a long or in a
wide format. The wide format needs columns with the quantile forecasts
\itemize{
  \item {quantile forecasts} a number of pairs of columns with
  quantile predictions for a certain range. For a 50% interval
  (corresponding to the 25% and
  75% quantile), one column has to be named \code{lower_50} and one
  \code{upper_50}.
  For the median, there has to a column \code{lower_0} and one
  \code{upper_0}
  }
The long format needs the following columns
\itemize{
  \item \code{predictions} the quantile forecasts
  \item \code{boundary} values should be either "lower" or "upper", depending
  on whether the prediction is for the lower or upper bound of a given range
  \item {range} the range for which a forecast was made. For a 50\% interval
  the range should be 50. The forecast for the 25\% quantile should have
  the value in the \code{predictions} column, the value of \code{range}
  should be 50 and the value of \code{boundary} should be "lower".
  If you want to score the median (i.e. \code{range = 0}), you still
  need to include a lower and an upper estimate, so the median has to
  appear twice.}}

\item{by}{character vector of columns to group scoring by. This should be the
lowest level of grouping possible, i.e. the unit of the individual
observation. This is important as many functions work on individual
observations. If you want a different level of aggregation, you should use
\code{summarise_by} to aggregate the individual scores.
Also not that the pit will be computed using \code{summarise_by}
instead of \code{by}}

\item{summarise_by}{character vector of columns to group the summary by. By
default, this is equal to `by` and no summary takes place.
But sometimes you may want to to summarise
over categories different from the scoring. If you e.g. want to have the
quantiles for plotting you may want to score by regions, but then summarise
over these regions.
\code{summarise_by} is the grouping level used to compute (and possibly plot)
the pit.}

\item{quantiles}{numeric vector of quantiles to be returned when summarising.
Instead of just returning a mean, quantiles will be returned for the
groups specified through `summarise_by`. By default, no quantiles are
returned.}

\item{sd}{if TRUE (the default is FALSE) the standard deviation of all
metrics will be returned when summarising.}

\item{pit_plots}{if TRUE (not the default), pit plots will be returned. For
details see \code{\link{pit}}.}

\item{pit_arguments}{pass down additional arguments to the \code{\link{pit}}
function.}

\item{interval_score_arguments}{pass down additional arguments to the
\code{\link{interval_score}} function, e.g. \code{weigh = FAlSE}.}
}
\value{
A data.table with appropriate scores. For binary predictions,
the Brier Score will be returned, for quantile predictions the interval
score, as well as adapted metrics for calibration, sharpness and bias.
For integer forecasts, Sharpness, Bias, DSS, CRPS, LogS, and
pit_p_val (as an indicator of calibration) are returned. For integer
forecasts, pit_sd is returned (to account for the randomised PIT),
but no Log Score is returned (the internal estimation relies on a
kernel density estimate which is difficult for integer-valued forecasts).
If \code{summarise_by} is specified differently from \code{by},
the average score per summary unit is returned.
If specified, quantiles and standard deviation of scores can also be returned
when summarising.
}
\description{
The function \code{eval_forecasts} is an easy to use wrapper
of the lower level functions in the \code{scoringutils} package.
It can be used to score probabilistic or quantile forecasts of
continuous, integer-valued or binary variables.
}
\details{
the following metrics are used where appropriate:
\itemize{
  \item {Interval Score} for quantile forecasts. Smaller is better. See
  \code{\link{interval_score}} for more information.
  \item {Brier Score} for a probability forecast of a binary outcome.
  Smaller is better. See \code{\link{brier_score}} for more information.
  \item {Bias} 0 is good, 1 and -1 are bad.
  See \code{\link{bias}} for more information.
  \item {Sharpness} Smaller is better. See \code{\link{sharpness}} for more
  information.
  \item {Calibration} represented through the p-value of the
  Anderson-Darling test for the uniformity of the Probability Integral
  Transformation (PIT). For integer valued forecasts, this p-value also
  has a standard deviation. Larger is better.
  See \code{\link{pit}} for more information.
  \item {DSS} Dawid-Sebastiani-Score. Smaller is better.
  See \code{\link{dss}} for more information.
  \item {CRPS} Continuous Ranked Probability Score. Smaller is better.
  See \code{\link{crps}} for more information.
  \item {Log Score} Smaller is better. Only for continuous forecasts.
  See \code{\link{logs}} for more information.
}
}
\examples{
## Probability Forecast for Binary Target
binary_example <- data.table::setDT(scoringutils::binary_example_data)
eval <- scoringutils::eval_forecasts(binary_example,
                                     by = c("id", "model", "horizon"),
                                     summarise_by = c("model"),
                                     quantiles = c(0.5), sd = TRUE)
eval2 <- scoringutils::eval_forecasts(binary_example,
                                     by = c("id", "model", "horizon"))

## Quantile Forecasts
# wide format
quantile_example <- data.table::setDT(scoringutils::quantile_example_data_wide)
eval <- scoringutils::eval_forecasts(quantile_example,
                                     by = c("model", "horizon", "id"),
                                     summarise_by = "model",
                                     quantiles = c(0.05, 0.95),
                                     sd = TRUE)
eval <- scoringutils::eval_forecasts(quantile_example,
                                     by = c("model", "horizon", "id"))

#long format
eval <- scoringutils::eval_forecasts(scoringutils::quantile_example_data_long,
                                     by = c("model", "horizon", "id"),
                                     summarise_by = c("model"))

## Integer Forecasts
integer_example <- data.table::setDT(scoringutils::integer_example_data)
eval <- scoringutils::eval_forecasts(integer_example,
                                     by = c("model", "id", "horizon"),
                                     summarise_by = c("model"),
                                     quantiles = c(0.1, 0.9),
                                     sd = TRUE,
                                     pit_plots = TRUE,
                                     pit_arguments = list(n_replicates = 30,
                                                          plot = TRUE))
eval <- scoringutils::eval_forecasts(integer_example,
                                     by = c("model", "id", "horizon"))

## Continuous Forecasts
continuous_example <- data.table::setDT(scoringutils::continuous_example_data)
eval <- scoringutils::eval_forecasts(continuous_example,
                                     by = c("model", "id" "horizon"))
eval <- scoringutils::eval_forecasts(continuous_example,
                                     quantiles = c(0.5, 0.9),
                                     sd = TRUE,
                                     by = c("model", "id", "horizon"),
                                     summarise_by = c("model"))

}
\references{
Funk S, Camacho A, Kucharski AJ, Lowe R, Eggo RM, Edmunds WJ
(2019) Assessing the performance of real-time epidemic forecasts: A
case study of Ebola in the Western Area region of Sierra Leone, 2014-15.
PLoS Comput Biol 15(2): e1006785.
\url{https://doi.org/10.1371/journal.pcbi.1006785}
}
\author{
Nikos Bosse \email{nikosbosse@gmail.com}
}
