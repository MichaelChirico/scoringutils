#' @title Available metrics in scoringutils
#'
#' @return A vector with the name of all available metrics
#' @export
#' @keywords info

available_metrics <- function() {
  return(unique(scoringutils::metrics$Name))
}


#' Safely delete Columns From a Data.table
#'
#' @description take a vector of column names and delete the columns if they
#' are present in the data.table
#' @param df A data.table or data.frame from which columns shall be deleted
#' @param cols_to_delete character vector with names of columns to be deleted
#' @param make_unique whether to make the data set unique after removing columns
#' @importFrom data.table as.data.table
#' @return A data.table
#'
#' @keywords internal
#'
delete_columns <- function(df, cols_to_delete, make_unique = FALSE) {
  df <- data.table::as.data.table(df)
  delete_columns <- names(df)[names(df) %in% cols_to_delete]
  if (length(delete_columns) > 0) {
    if (make_unique) {
      df <- unique(df[, eval(delete_columns) := NULL])
    } else {
      df <- df[, eval(delete_columns) := NULL]
    }
  }
  return(df)
}

remove_na_observed_predicted <- function(data) {
  # remove rows where predicted or observed value are NA -----------------------
  data <- data[!is.na(observed) & !is.na(predicted)]
  if (nrow(data) == 0) {
    stop("After removing NA values in `observed` and `predicted`, there were no observations left")
  }
  return(data[])
}





#' @title Collapse several messages to one
#'
#' @description Internal helper function to facilitate generating messages
#' and warnings.
#'
#' @param type character, should be either "messages", "warnings" or "errors"
#' @param messages the messages or warnings to collapse
#'
#' @return string with the message or warning
#' @keywords internal
collapse_messages <- function(type = "messages", messages) {
  paste0(
    "The following ",  type, " were produced when checking inputs:\n",
    paste(paste0(seq_along(messages), ". "), messages, collapse = "\n")
  )
}



#' @title Print output from `check_forecasts()`
#'
#' @description Helper function that prints the output generated by
#' `check_forecasts()`
#'
#' @param x An object of class 'scoringutils_check' as produced b y
#' `check_forecasts()`
#' @param ... additional arguments (not used here)
#'
#' @return NULL
#' @export
#' @keywords check-forecasts
#' @examples
#' check <- validate(example_quantile)
#' print(check)
print.scoringutils_check <- function(x, ...) {
  cat("Your forecasts seem to be for a target of the following type:\n")
  print(x["target_type"])
  cat("and in the following format:\n")
  print(x["prediction_type"])

  cat("The unit of a single forecast is defined by:\n")
  print(x["forecast_unit"])

  cat("Cleaned data, rows with NA values in predicted or observed removed:\n")
  print.default(x["cleaned_data"])

  cat("Number of unique values per column per model:\n")
  print.default(x["unique_values"])

  colnames <- names(x)[names(x) %in% c("messages", "warnings", "errors")]
  if (length(colnames) > 0) {
    print.default(x[colnames])
  }

  return(invisible(x))
}

#' @title Filter function arguments
#'
#' @description This function compares a list of arguments with the arguments
#' that a function can accept. It only returns those arguments that can be
#' passed to the function.
#'
#' The function is used in [score()] to handle additional arguments passed to
#' [score()] that get then passed along to the different scoring functions.
#'
#' @param fun A function to which arguments shall be passed
#' @param args A list of arguments that shall be passed to fun
#'
#' @return A list of function arguments (a subset of `args`) that `fun` can
#' accept.
#' @keywords internal
filter_function_args <- function(fun, args) {
  # Check if the function accepts ... as an argument
  if ("..." %in% names(formals(fun))) {
    # If it does, return all arguments
    return(args)
  } else {
    # Identify the arguments that fun() accepts and only keep valid ones
    valid_args <- names(formals(fun))
    return(args[names(args) %in% valid_args])
  }
}

